{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Manticore OrderBook","text":"<p>A high-performance, feature-rich limit order book implementation for financial trading applications.</p> <p> </p>"},{"location":"#features","title":"Features","text":"<p>\u2705 Complete Order Book Implementation - Full-featured limit order book with best-in-class performance \u2705 Multiple Order Types - Support for limit, market, FOK, IOC, post-only, and GTD orders \u2705 Price Improvement - Optional price improvement for better execution \u2705 Event-Driven Architecture - Real-time events for order added, cancelled, and trades executed \u2705 High Performance - Optimized for high-throughput trading (17,000+ orders/second) \u2705 Comprehensive API - Clean, intuitive interface with extensive documentation \u2705 Production Ready - Extensively tested and benchmarked</p>"},{"location":"#installation","title":"Installation","text":"<pre><code># From PyPI\npip3 install manticore-orderbook\n\n# From source\ngit clone https://github.com/manticoretechnologies/manticore-orderbook.git\ncd manticore-orderbook\npip3 install -e .\n</code></pre>"},{"location":"#quick-start","title":"Quick Start","text":"<pre><code>from manticore_orderbook import OrderBook\nfrom manticore_orderbook.enums import Side, EventType\n\n# Create an order book for BTC/USD\norderbook = OrderBook(\"BTC\", \"USD\")\n\n# Register event handlers\ndef on_trade(event):\n    print(f\"Trade executed: {event.amount} @ {event.price}\")\n\norderbook.event_manager.register(EventType.TRADE_EXECUTED, on_trade)\n\n# Add orders\norderbook.add_order(\"bid1\", Side.BUY, 10000.00, 1.0)\norderbook.add_order(\"ask1\", Side.SELL, 10100.00, 0.5)\n\n# Get a snapshot of the current order book state\nsnapshot = orderbook.get_snapshot()\nprint(f\"Best bid: {snapshot['bids'][0]['price'] if snapshot['bids'] else 'None'}\")\nprint(f\"Best ask: {snapshot['asks'][0]['price'] if snapshot['asks'] else 'None'}\")\n\n# Add a matching order that will execute\norderbook.add_order(\"match1\", Side.BUY, 10100.00, 0.2)\n</code></pre> <p>For more detailed instructions, please see the User Guide.</p>"},{"location":"#visualization","title":"Visualization","text":"<p>Manticore OrderBook includes a visualization server for real-time order book display:</p> <pre><code>python3 -m tests.visual.orderbook_visualizer\n</code></pre> <p>This will start a web server that you can access at http://127.0.0.1:5000 to view a real-time visualization of the order book with interactive features.</p> <p>For more detailed instructions, please see the User Guide.</p>"},{"location":"SUMMARY/","title":"Manticore OrderBook Documentation","text":"<ul> <li>Introduction</li> <li>User Guide</li> <li>API Reference</li> <li>Integration</li> <li>Events System</li> <li>Changelog </li> </ul>"},{"location":"api-reference/","title":"API Reference","text":"<p>This page documents the main classes and methods of the Manticore OrderBook library.</p>"},{"location":"api-reference/#orderbook-class","title":"OrderBook Class","text":"<p>The main class that implements the order book functionality.</p> <pre><code>class OrderBook:\n    def __init__(self, symbol: str, max_trade_history: int = 10000,\n                 maker_fee_rate: float = 0.0, taker_fee_rate: float = 0.0,\n                 enable_logging: bool = True, log_level: int = logging.INFO,\n                 check_expiry_interval: float = 1.0,\n                 event_manager: Optional[EventManager] = None,\n                 enable_price_improvement: bool = True)\n</code></pre>"},{"location":"api-reference/#constructor-parameters","title":"Constructor Parameters","text":"<ul> <li><code>symbol</code>: Trading pair symbol (e.g., \"BTC/USD\")</li> <li><code>max_trade_history</code>: Maximum number of trades to keep in history</li> <li><code>maker_fee_rate</code>: Fee rate for makers (liquidity providers)</li> <li><code>taker_fee_rate</code>: Fee rate for takers (liquidity takers)</li> <li><code>enable_logging</code>: Whether to enable logging</li> <li><code>log_level</code>: Logging level (from Python's logging module)</li> <li><code>check_expiry_interval</code>: Interval in seconds to check for expired orders</li> <li><code>event_manager</code>: Custom event manager instance (optional)</li> <li><code>enable_price_improvement</code>: Whether to enable price improvement for orders</li> </ul>"},{"location":"api-reference/#main-methods","title":"Main Methods","text":""},{"location":"api-reference/#adding-orders","title":"Adding Orders","text":"<pre><code>def add_order(self, side: str, price: float, quantity: float, order_id: Optional[str] = None,\n              time_in_force: Optional[str] = None, expiry_time: Optional[float] = None,\n              user_id: Optional[str] = None, order_type: Optional[str] = None,\n              stop_price: Optional[float] = None, trail_value: Optional[float] = None,\n              trail_is_percent: bool = False, displayed_quantity: Optional[float] = None) -&gt; str\n</code></pre> <p>Adds a new order to the order book.</p>"},{"location":"api-reference/#cancelling-orders","title":"Cancelling Orders","text":"<pre><code>def cancel_order(self, order_id: str) -&gt; bool\n</code></pre> <p>Cancels an existing order.</p>"},{"location":"api-reference/#modifying-orders","title":"Modifying Orders","text":"<pre><code>def modify_order(self, order_id: str, new_price: Optional[float] = None, \n                 new_quantity: Optional[float] = None,\n                 new_expiry_time: Optional[float] = None,\n                 new_stop_price: Optional[float] = None,\n                 new_trail_value: Optional[float] = None,\n                 new_trail_is_percent: Optional[bool] = None,\n                 new_displayed_quantity: Optional[float] = None) -&gt; bool\n</code></pre> <p>Modifies an existing order.</p>"},{"location":"api-reference/#getting-the-order-book-snapshot","title":"Getting the Order Book Snapshot","text":"<pre><code>def get_snapshot(self, depth: int = None) -&gt; Dict[str, Any]\n</code></pre> <p>Returns a snapshot of the current state of the order book.</p>"},{"location":"api-reference/#getting-order-details","title":"Getting Order Details","text":"<pre><code>def get_order(self, order_id: str) -&gt; Optional[Dict[str, Any]]\n</code></pre> <p>Returns details of a specific order.</p>"},{"location":"api-reference/#getting-trade-history","title":"Getting Trade History","text":"<pre><code>def get_trade_history(self, limit: int = 100) -&gt; List[Dict[str, Any]]\n</code></pre> <p>Returns the trade history.</p>"},{"location":"api-reference/#order-class","title":"Order Class","text":"<p>Represents an order in the order book.</p> <pre><code>class Order:\n    def __init__(\n        self, \n        side: Union[str, Side], \n        price: float, \n        quantity: float, \n        order_id: Optional[str] = None,\n        timestamp: Optional[float] = None,\n        time_in_force: Union[str, TimeInForce, None] = None,\n        expiry_time: Optional[float] = None,\n        user_id: Optional[str] = None,\n        order_type: Union[str, OrderType, None] = None,\n        stop_price: Optional[float] = None,\n        trail_value: Optional[float] = None,\n        trail_is_percent: bool = False,\n        displayed_quantity: Optional[float] = None\n    )\n</code></pre>"},{"location":"api-reference/#constructor-parameters_1","title":"Constructor Parameters","text":"<ul> <li><code>side</code>: Order side ('buy' or 'sell')</li> <li><code>price</code>: Order price</li> <li><code>quantity</code>: Order quantity</li> <li><code>order_id</code>: Unique order ID (generated if not provided)</li> <li><code>timestamp</code>: Order timestamp (current time if not provided)</li> <li><code>time_in_force</code>: Time-in-force option ('GTC', 'IOC', 'FOK', 'GTD')</li> <li><code>expiry_time</code>: Time when the order expires (required for GTD)</li> <li><code>user_id</code>: User ID who placed the order</li> <li><code>order_type</code>: Type of order ('LIMIT', 'MARKET', 'STOP_LIMIT', etc.)</li> <li><code>stop_price</code>: Price at which stop orders are triggered</li> <li><code>trail_value</code>: Value or percentage for trailing stop orders</li> <li><code>trail_is_percent</code>: Whether trail_value is a percentage</li> <li><code>displayed_quantity</code>: Visible quantity for iceberg orders</li> </ul>"},{"location":"api-reference/#main-methods_1","title":"Main Methods","text":""},{"location":"api-reference/#updating-an-order","title":"Updating an Order","text":"<pre><code>def update(self, price: Optional[float] = None, quantity: Optional[float] = None,\n           expiry_time: Optional[float] = None, stop_price: Optional[float] = None, \n           trail_value: Optional[float] = None, trail_is_percent: Optional[bool] = None,\n           displayed_quantity: Optional[float] = None) -&gt; None\n</code></pre> <p>Updates an order's properties.</p>"},{"location":"api-reference/#checking-expiration","title":"Checking Expiration","text":"<pre><code>def is_expired(self, current_time: Optional[float] = None) -&gt; bool\n</code></pre> <p>Checks if the order has expired.</p>"},{"location":"api-reference/#serialization","title":"Serialization","text":"<pre><code>def to_dict(self) -&gt; Dict[str, Any]\n</code></pre> <p>Converts order to dictionary representation.</p> <pre><code>@classmethod\ndef from_dict(cls, data: Dict[str, Any]) -&gt; 'Order'\n</code></pre> <p>Creates an order from a dictionary.</p>"},{"location":"api-reference/#trade-class","title":"Trade Class","text":"<p>Represents a trade in the order book.</p> <pre><code>class Trade:\n    def __init__(\n        self,\n        maker_order_id: str,\n        taker_order_id: str,\n        price: float,\n        quantity: float,\n        trade_id: Optional[str] = None,\n        timestamp: Optional[float] = None,\n        maker_fee: Optional[float] = None,\n        taker_fee: Optional[float] = None,\n        maker_fee_rate: float = 0.0,\n        taker_fee_rate: float = 0.0,\n        maker_user_id: Optional[str] = None,\n        taker_user_id: Optional[str] = None\n    )\n</code></pre>"},{"location":"api-reference/#constructor-parameters_2","title":"Constructor Parameters","text":"<ul> <li><code>maker_order_id</code>: ID of the maker order</li> <li><code>taker_order_id</code>: ID of the taker order</li> <li><code>price</code>: Trade execution price</li> <li><code>quantity</code>: Trade quantity</li> <li><code>trade_id</code>: Unique trade ID (generated if not provided)</li> <li><code>timestamp</code>: Trade timestamp (current time if not provided)</li> <li><code>maker_fee</code>: Explicit maker fee (if None, calculated from rate)</li> <li><code>taker_fee</code>: Explicit taker fee (if None, calculated from rate)</li> <li><code>maker_fee_rate</code>: Fee rate for maker (e.g., 0.001 for 0.1%)</li> <li><code>taker_fee_rate</code>: Fee rate for taker (e.g., 0.002 for 0.2%)</li> <li><code>maker_user_id</code>: User ID of the maker</li> <li><code>taker_user_id</code>: User ID of the taker</li> </ul>"},{"location":"api-reference/#main-methods_2","title":"Main Methods","text":""},{"location":"api-reference/#serialization_1","title":"Serialization","text":"<pre><code>def to_dict(self) -&gt; Dict[str, Any]\n</code></pre> <p>Converts trade to dictionary representation.</p> <pre><code>@classmethod\ndef from_dict(cls, data: Dict[str, Any]) -&gt; 'Trade'\n</code></pre> <p>Creates a trade from a dictionary.</p>"},{"location":"api-reference/#eventmanager-class","title":"EventManager Class","text":"<p>Manages events in the order book system.</p> <pre><code>class EventManager:\n    def __init__(self, enable_logging: bool = True, log_level: int = logging.INFO,\n                 max_history_size: int = 1000)\n</code></pre>"},{"location":"api-reference/#constructor-parameters_3","title":"Constructor Parameters","text":"<ul> <li><code>enable_logging</code>: Whether to enable logging</li> <li><code>log_level</code>: Logging level</li> <li><code>max_history_size</code>: Maximum number of events to keep in history</li> </ul>"},{"location":"api-reference/#main-methods_3","title":"Main Methods","text":""},{"location":"api-reference/#event-subscription","title":"Event Subscription","text":"<pre><code>def subscribe(self, event_type: EventType, handler: EventHandler) -&gt; None\n</code></pre> <p>Subscribes a handler to an event type.</p> <pre><code>def unsubscribe(self, event_type: EventType, handler: EventHandler) -&gt; bool\n</code></pre> <p>Unsubscribes a handler from an event type.</p>"},{"location":"api-reference/#event-publishing","title":"Event Publishing","text":"<pre><code>def publish(self, event_type: EventType, data: Dict[str, Any], symbol: Optional[str] = None) -&gt; None\n</code></pre> <p>Publishes an event to all subscribers.</p>"},{"location":"api-reference/#event-history","title":"Event History","text":"<pre><code>def get_event_history(self, limit: int = 100, event_type: Optional[EventType] = None,\n                     symbol: Optional[str] = None) -&gt; List[Dict[str, Any]]\n</code></pre> <p>Retrieves event history with optional filtering. </p>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to the manticore-orderbook project are documented here.</p>"},{"location":"changelog/#101-2025-03-08","title":"[1.0.1] - 2025-03-08","text":""},{"location":"changelog/#enhanced","title":"Enhanced","text":"<ul> <li>Improved market order processing reliability</li> <li>Enhanced visualization interface with horizontal layout</li> <li>Fixed error handling for invalid inputs</li> </ul>"},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li>Modernized UI design for the visualization tool</li> <li>Updated company information across all documentation</li> <li>Improved socket connection reliability</li> <li>Enhanced error handling and user feedback</li> </ul>"},{"location":"changelog/#added","title":"Added","text":"<ul> <li>New notification system for trade confirmations</li> <li>Better metrics display for market data</li> <li>Improved responsive design for different screen sizes</li> </ul>"},{"location":"changelog/#100-2023-03-06","title":"[1.0.0] - 2023-03-06","text":""},{"location":"changelog/#major-refactoring","title":"Major Refactoring","text":"<ul> <li>Complete refactoring of the codebase to focus on core orderbook functionality</li> <li>Removed market manager, storage, and API modules to focus on integration-ready design</li> <li>Enhanced event system for improved integration with external systems</li> </ul>"},{"location":"changelog/#changed_1","title":"Changed","text":"<ul> <li>Redesigned the module to focus on a single responsibility - order book management</li> <li>Improved event system for better integration with external systems</li> <li>Comprehensive documentation for integration with other modules</li> <li>More consistent APIs and data structures</li> </ul>"},{"location":"changelog/#removed","title":"Removed","text":"<ul> <li>Removed <code>MarketManager</code> (to be replaced by external module)</li> <li>Removed storage functionality (to be handled by manticore-storage)</li> <li>Removed API server functionality</li> <li>Removed example files not related to core functionality</li> </ul>"},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li>New integration guides for connecting with other modules</li> <li>Detailed event system documentation</li> <li>Improved integration patterns and examples</li> </ul>"},{"location":"changelog/#030-2023-02-15","title":"[0.3.0] - 2023-02-15","text":""},{"location":"changelog/#added_2","title":"Added","text":"<ul> <li>Added batch operations for improved performance</li> <li>Implemented price improvement feature</li> <li>Added latency monitoring for performance analysis</li> </ul>"},{"location":"changelog/#changed_2","title":"Changed","text":"<ul> <li>Optimized depth queries with caching</li> <li>Improved thread safety for concurrent operations</li> <li>Enhanced fee calculation</li> </ul>"},{"location":"changelog/#020-2023-01-20","title":"[0.2.0] - 2023-01-20","text":""},{"location":"changelog/#added_3","title":"Added","text":"<ul> <li>Added Time-In-Force support (GTC, IOC, FOK, GTD)</li> <li>Implemented order expiry management</li> <li>Added user tracking for fee calculation</li> </ul>"},{"location":"changelog/#changed_3","title":"Changed","text":"<ul> <li>Improved matching algorithm efficiency</li> <li>Enhanced error handling and logging</li> </ul>"},{"location":"changelog/#010-2023-01-05","title":"[0.1.0] - 2023-01-05","text":""},{"location":"changelog/#added_4","title":"Added","text":"<ul> <li>Initial implementation of OrderBook with price-time priority</li> <li>Basic order management (add, modify, cancel)</li> <li>Simple matching engine</li> <li>Snapshot functionality</li> <li>Trade history tracking </li> </ul>"},{"location":"events/","title":"Manticore OrderBook Event System","text":"<p>The event system is a core feature of the Manticore OrderBook, enabling loose coupling between components and providing a foundation for integrating with external systems like storage, matching engines, and API servers.</p>"},{"location":"events/#event-types","title":"Event Types","text":"<p>The <code>EventType</code> enum in <code>manticore_orderbook.event_manager</code> defines all the events that can be published:</p>"},{"location":"events/#order-lifecycle-events","title":"Order Lifecycle Events","text":"Event Type Description When It's Triggered Key Data Fields <code>ORDER_ADDED</code> An order has been added to the order book After an order is successfully added order_id, side, price, quantity, timestamp, time_in_force, expiry_time, user_id <code>ORDER_MODIFIED</code> An existing order has been modified After an order's price, quantity, or expiry time is changed order_id, side, price, old_quantity, new_quantity, old_expiry_time, new_expiry_time, timestamp, user_id <code>ORDER_CANCELLED</code> An order has been cancelled After an order is successfully removed from the book order_id, side, price, quantity, timestamp, user_id <code>ORDER_FILLED</code> An order has been partially or fully filled After a trade that partially or fully fills an order order_id, fill_price, fill_quantity, remaining_quantity, timestamp, user_id, is_maker, fee <code>ORDER_EXPIRED</code> An order has expired due to time-in-force When the expiry checker finds an expired order order_id, side, price, quantity, expiry_time, user_id"},{"location":"events/#trade-events","title":"Trade Events","text":"Event Type Description When It's Triggered Key Data Fields <code>TRADE_EXECUTED</code> A trade has been executed After a successful match between orders maker_order_id, taker_order_id, price, quantity, timestamp, maker_user_id, taker_user_id, maker_fee, taker_fee"},{"location":"events/#price-level-events","title":"Price Level Events","text":"Event Type Description When It's Triggered Key Data Fields <code>PRICE_LEVEL_ADDED</code> A new price level has been added When the first order at a price is added side, price, quantity, order_count <code>PRICE_LEVEL_REMOVED</code> A price level has been removed When the last order at a price is removed side, price, timestamp <code>PRICE_LEVEL_CHANGED</code> The quantity at a price level has changed When orders are added/removed/modified at an existing price side, price, quantity, order_count, timestamp"},{"location":"events/#book-events","title":"Book Events","text":"Event Type Description When It's Triggered Key Data Fields <code>BOOK_UPDATED</code> General update to book state After any significant change to the book timestamp <code>DEPTH_CHANGED</code> The top N levels of the book changed When price levels near the top of the book change timestamp, top_bid, top_ask <code>SNAPSHOT_CREATED</code> A snapshot of the book has been created When a snapshot is explicitly created symbol, timestamp"},{"location":"events/#using-the-event-system","title":"Using the Event System","text":""},{"location":"events/#subscribing-to-events","title":"Subscribing to Events","text":"<p>To listen for specific events, you can subscribe a handler function to one or more event types:</p> <pre><code>from manticore_orderbook import OrderBook\nfrom manticore_orderbook.enums import EventType\n\n# Create an order book\norderbook = OrderBook(\"BTC/USD\")\n\n# Define your event handler function\ndef on_trade(event_type, data):\n    print(f\"Trade executed: {data['quantity']} @ {data['price']}\")\n    print(f\"Maker: {data['maker_order_id']}, Taker: {data['taker_order_id']}\")\n\n# Subscribe to trade events\norderbook.event_manager.subscribe(EventType.TRADE_EXECUTED, on_trade)\n</code></pre>"},{"location":"events/#handling-multiple-event-types","title":"Handling Multiple Event Types","text":"<p>You can subscribe a single handler to multiple event types:</p> <pre><code>def order_lifecycle_handler(event_type, data):\n    if event_type == EventType.ORDER_ADDED:\n        print(f\"Order added: {data['order_id']}\")\n    elif event_type == EventType.ORDER_MODIFIED:\n        print(f\"Order modified: {data['order_id']}\")\n    elif event_type == EventType.ORDER_CANCELLED:\n        print(f\"Order cancelled: {data['order_id']}\")\n    elif event_type == EventType.ORDER_FILLED:\n        print(f\"Order filled: {data['order_id']}, quantity: {data['fill_quantity']}\")\n\n# Subscribe to multiple events\nfor event_type in [EventType.ORDER_ADDED, EventType.ORDER_MODIFIED, \n                  EventType.ORDER_CANCELLED, EventType.ORDER_FILLED]:\n    orderbook.event_manager.subscribe(event_type, order_lifecycle_handler)\n</code></pre>"},{"location":"events/#unsubscribing-from-events","title":"Unsubscribing from Events","text":"<p>You can unsubscribe a handler when you no longer need it:</p> <pre><code># Unsubscribe from an event\norderbook.event_manager.unsubscribe(EventType.TRADE_EXECUTED, on_trade)\n\n# Unsubscribe from all events (for a specific handler)\norderbook.event_manager.unsubscribe_all(order_lifecycle_handler)\n</code></pre>"},{"location":"events/#subscribing-to-all-events","title":"Subscribing to All Events","text":"<p>For logging or monitoring purposes, you might want to subscribe to all events:</p> <pre><code>def log_all_events(event_type, data):\n    print(f\"Event: {event_type}, Data: {data}\")\n\n# Subscribe to all events\norderbook.event_manager.subscribe_all(log_all_events)\n</code></pre>"},{"location":"events/#example-building-a-websocket-feed","title":"Example: Building a WebSocket Feed","text":"<p>Here's how you could use the event system to build a real-time WebSocket feed:</p> <pre><code>from flask import Flask\nfrom flask_socketio import SocketIO\nfrom manticore_orderbook import OrderBook\nfrom manticore_orderbook.enums import EventType\n\napp = Flask(__name__)\nsocketio = SocketIO(app)\norderbook = OrderBook(\"BTC/USD\")\n\n# Send events to WebSocket clients\ndef emit_event(event_type, data):\n    event_name = str(event_type).replace('EventType.', '').lower()\n    socketio.emit(event_name, data)\n\n# Subscribe to all relevant events\nfor event_type in [EventType.ORDER_ADDED, EventType.ORDER_CANCELLED, \n                  EventType.ORDER_FILLED, EventType.TRADE_EXECUTED,\n                  EventType.BOOK_UPDATED]:\n    orderbook.event_manager.subscribe(event_type, emit_event)\n\n# WebSocket endpoint to get the current order book\n@socketio.on('get_orderbook')\ndef handle_get_orderbook():\n    snapshot = orderbook.get_snapshot(depth=20)\n    return snapshot\n\nif __name__ == '__main__':\n    socketio.run(app, debug=True)\n</code></pre>"},{"location":"integration/","title":"Integrating Manticore OrderBook","text":"<p>This guide provides detailed instructions on how to integrate the Manticore OrderBook module with other components of your cryptocurrency exchange system.</p>"},{"location":"integration/#introduction","title":"Introduction","text":"<p>Manticore OrderBook is designed as a core component in a modular exchange architecture. It focuses on efficiently managing order books with price-time priority matching, while delegating other concerns like persistence, authentication, and risk management to specialized modules.</p> <p>The key interface between Manticore OrderBook and other modules is the event system. By subscribing to events from the OrderBook, other modules can react to changes in the order book state without tight coupling between components.</p>"},{"location":"integration/#architecture-diagram","title":"Architecture Diagram","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  manticore-auth   \u2502      \u2502  manticore-risk   \u2502      \u2502   manticore-api   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n          \u2502                          \u2502                          \u2502\n          \u2502                          \u2502                          \u2502\n          \u2502                          \u2502                          \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 manticore-orderbook\u25c4\u2500\u2500\u2500\u2500\u2500\u25bamanticore-storage  \u2502      \u2502manticore-matching \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n          \u2502                          \u2502                          \u2502\n          \u2502                          \u2502                          \u2502\n          \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"integration/#integration-with-storage-systems","title":"Integration with Storage Systems","text":"<p>The storage module handles persistent storage of order data, trade history, and other information needed for an exchange. Here's how to integrate the two modules:</p>"},{"location":"integration/#setup","title":"Setup","text":"<ol> <li>Initialize both modules:</li> </ol> <pre><code>from manticore_orderbook import OrderBook, EventManager, EventType\nfrom manticore_storage import StorageManager  # Assumed interface\n\n# Create instances\nevent_manager = EventManager()\norderbook = OrderBook(symbol=\"BTC/USD\")\nstorage = StorageManager(connection_string=\"your_db_connection_string\")\n</code></pre>"},{"location":"integration/#event-based-persistence","title":"Event-Based Persistence","text":"<ol> <li>Subscribe to orderbook events to persist changes:</li> </ol> <pre><code># Handler for order events\ndef handle_order_event(event_type, data):\n    if event_type == EventType.ORDER_ADDED:\n        # Store new order\n        storage.save_order(data)\n    elif event_type == EventType.ORDER_MODIFIED:\n        # Update existing order\n        storage.update_order(data[\"order_id\"], data)\n    elif event_type == EventType.ORDER_CANCELLED:\n        # Mark order as cancelled\n        storage.mark_order_cancelled(data[\"order_id\"])\n    elif event_type == EventType.ORDER_FILLED:\n        # Update fill status\n        storage.update_order_fill(data[\"order_id\"], data[\"filled_quantity\"])\n\n# Handler for trade events\ndef handle_trade_event(event_type, data):\n    # Store trade record\n    storage.save_trade(data)\n\n# Subscribe to events\nevent_manager.subscribe(EventType.ORDER_ADDED, handle_order_event)\nevent_manager.subscribe(EventType.ORDER_MODIFIED, handle_order_event)\nevent_manager.subscribe(EventType.ORDER_CANCELLED, handle_order_event)\nevent_manager.subscribe(EventType.ORDER_FILLED, handle_order_event)\nevent_manager.subscribe(EventType.TRADE_EXECUTED, handle_trade_event)\n</code></pre>"},{"location":"integration/#restoring-state-from-storage","title":"Restoring State from Storage","text":"<ol> <li>Initialize orderbook from storage:</li> </ol> <pre><code># When starting the system, load existing active orders\ndef initialize_orderbook_from_storage():\n    active_orders = storage.get_active_orders(symbol=\"BTC/USD\")\n\n    # Sort by timestamp to maintain proper time priority\n    sorted_orders = sorted(active_orders, key=lambda x: x[\"timestamp\"])\n\n    # Add orders to the orderbook\n    for order in sorted_orders:\n        orderbook.add_order(\n            order_id=order[\"order_id\"],\n            side=order[\"side\"],\n            price=order[\"price\"],\n            quantity=order[\"quantity\"],\n            time_in_force=order[\"time_in_force\"],\n            expiry_time=order[\"expiry_time\"],\n            user_id=order[\"user_id\"],\n            order_type=order[\"order_type\"]\n        )\n</code></pre>"},{"location":"integration/#integration-with-api-servers","title":"Integration with API Servers","text":"<p>To integrate Manticore OrderBook with a REST or WebSocket API server:</p> <pre><code>from flask import Flask, request, jsonify\nfrom manticore_orderbook import OrderBook\n\napp = Flask(__name__)\norderbook = OrderBook(symbol=\"BTC/USD\")\n\n@app.route('/api/orders', methods=['POST'])\ndef place_order():\n    data = request.json\n\n    try:\n        order_id = orderbook.add_order(\n            side=data['side'],\n            price=data.get('price'),  # None for market orders\n            quantity=data['quantity'],\n            order_id=data.get('client_order_id'),  # Optional client-provided ID\n            time_in_force=data.get('time_in_force', 'GTC'),\n            user_id=data.get('user_id')\n        )\n\n        return jsonify({\n            \"status\": \"success\",\n            \"order_id\": order_id\n        }), 201\n    except Exception as e:\n        return jsonify({\n            \"status\": \"error\",\n            \"message\": str(e)\n        }), 400\n\n@app.route('/api/orders/&lt;order_id&gt;', methods=['DELETE'])\ndef cancel_order(order_id):\n    success = orderbook.cancel_order(order_id)\n\n    if success:\n        return jsonify({\n            \"status\": \"success\",\n            \"message\": f\"Order {order_id} cancelled\"\n        }), 200\n    else:\n        return jsonify({\n            \"status\": \"error\",\n            \"message\": f\"Order {order_id} not found or already filled\"\n        }), 404\n\n@app.route('/api/orderbook', methods=['GET'])\ndef get_orderbook():\n    depth = request.args.get('depth', default=10, type=int)\n    snapshot = orderbook.get_snapshot(depth=depth)\n\n    return jsonify(snapshot), 200\n</code></pre>"},{"location":"integration/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Error Handling: Always wrap order operations in try-except blocks to handle invalid orders gracefully.</p> </li> <li> <p>Batch Operations: When loading multiple orders, use batch operations when available to improve performance.</p> </li> <li> <p>Consistency Checks: Periodically verify that the database state and in-memory orderbook state are consistent.</p> </li> <li> <p>Event Ordering: Be aware of event ordering when subscribing to multiple event types. Some operations may depend on events being processed in a specific order.</p> </li> <li> <p>Connection Management: Implement reconnection logic for database connections and ensure proper cleanup on shutdown. </p> </li> </ol>"},{"location":"user-guide/","title":"Manticore OrderBook User Guide","text":""},{"location":"user-guide/#introduction","title":"Introduction","text":"<p>Manticore OrderBook is a high-performance trading order book implementation written in Python. It provides a complete solution for financial trading applications, supporting multiple order types, advanced matching algorithms, and real-time market data processing.</p>"},{"location":"user-guide/#installation","title":"Installation","text":"<p>Install the package from PyPI:</p> <pre><code>pip3 install manticore-orderbook\n</code></pre> <p>Or install from source:</p> <pre><code>git clone https://github.com/manticoretechnologies/manticore-orderbook.git\ncd manticore-orderbook\npip3 install -e .\n</code></pre>"},{"location":"user-guide/#getting-started","title":"Getting Started","text":""},{"location":"user-guide/#basic-usage","title":"Basic Usage","text":"<pre><code>from manticore_orderbook import OrderBook\nfrom manticore_orderbook.enums import Side\n\n# Create an order book for BTC/USD\norderbook = OrderBook(\"BTC\", \"USD\", price_precision=2, quantity_precision=8)\n\n# Add some orders\norderbook.add_order(\"order1\", Side.BUY, 10000.00, 1.0)  # Buy 1 BTC at $10,000\norderbook.add_order(\"order2\", Side.BUY, 9900.00, 2.0)   # Buy 2 BTC at $9,900\norderbook.add_order(\"order3\", Side.SELL, 10100.00, 1.5) # Sell 1.5 BTC at $10,100\norderbook.add_order(\"order4\", Side.SELL, 10200.00, 0.5) # Sell 0.5 BTC at $10,200\n\n# Get the current state of the order book\nsnapshot = orderbook.get_snapshot()\nprint(\"Current Order Book State:\")\nprint(f\"Bids: {snapshot['bids']}\")\nprint(f\"Asks: {snapshot['asks']}\")\n\n# Add a matching order that will execute immediately\norderbook.add_order(\"order5\", Side.BUY, 10100.00, 0.5)  # This will match with order3\n\n# Get the executed trades\ntrades = orderbook.get_trades()\nprint(\"\\nExecuted Trades:\")\nfor trade in trades:\n    print(f\"Price: {trade.price}, Amount: {trade.amount}, Taker: {trade.taker_order_id}, Maker: {trade.maker_order_id}\")\n</code></pre>"},{"location":"user-guide/#order-types","title":"Order Types","text":"<p>Manticore OrderBook supports multiple order types through its strategy pattern:</p>"},{"location":"user-guide/#limit-orders","title":"Limit Orders","text":"<p>The default order type. Specifies a price at which to buy or sell.</p> <pre><code>orderbook.add_order(\"limit1\", Side.BUY, 10000.00, 1.0)  # Standard limit order\n</code></pre>"},{"location":"user-guide/#market-orders","title":"Market Orders","text":"<p>Execute immediately at the best available price.</p> <pre><code>from manticore_orderbook.strategies import MarketOrderStrategy\n\n# Market buy order for 0.5 BTC\norderbook.add_order(\"market1\", Side.BUY, None, 0.5, strategy=MarketOrderStrategy())\n</code></pre>"},{"location":"user-guide/#fill-or-kill-fok-orders","title":"Fill-or-Kill (FOK) Orders","text":"<p>Must be filled completely or not at all.</p> <pre><code>from manticore_orderbook.strategies import FOKOrderStrategy\n\n# FOK buy order - buy 2 BTC at $10,050 or cancel\norderbook.add_order(\"fok1\", Side.BUY, 10050.00, 2.0, strategy=FOKOrderStrategy())\n</code></pre>"},{"location":"user-guide/#immediate-or-cancel-ioc-orders","title":"Immediate-or-Cancel (IOC) Orders","text":"<p>Execute immediately what can be filled and cancel the rest.</p> <pre><code>from manticore_orderbook.strategies import IOCOrderStrategy\n\n# IOC sell order - sell up to 1 BTC at $10,100, cancel remainder\norderbook.add_order(\"ioc1\", Side.SELL, 10100.00, 1.0, strategy=IOCOrderStrategy())\n</code></pre>"},{"location":"user-guide/#post-only-orders","title":"Post-Only Orders","text":"<p>Only add liquidity, never take it. Reject if would execute immediately.</p> <pre><code>from manticore_orderbook.strategies import PostOnlyOrderStrategy\n\n# Post-only buy order - add to book only if doesn't match\norderbook.add_order(\"post1\", Side.BUY, 9900.00, 3.0, strategy=PostOnlyOrderStrategy())\n</code></pre>"},{"location":"user-guide/#good-till-date-gtd-orders","title":"Good-Till-Date (GTD) Orders","text":"<p>Remain active until a specified expiration time.</p> <pre><code>from manticore_orderbook.strategies import GTDOrderStrategy\nimport datetime\n\n# Order expires in 24 hours\nexpiry = datetime.datetime.now() + datetime.timedelta(days=1)\norderbook.add_order(\"gtd1\", Side.SELL, 10200.00, 0.75, strategy=GTDOrderStrategy(expiry))\n</code></pre>"},{"location":"user-guide/#advanced-usage","title":"Advanced Usage","text":""},{"location":"user-guide/#price-improvement","title":"Price Improvement","text":"<p>Manticore OrderBook supports price improvement, which allows orders to be executed at better prices than requested:</p> <pre><code># Create an order book with price improvement enabled\norderbook = OrderBook(\"ETH\", \"USD\", enable_price_improvement=True)\n\n# Add orders\norderbook.add_order(\"sell1\", Side.SELL, 2000.00, 1.0)\norderbook.add_order(\"sell2\", Side.SELL, 1990.00, 1.0)  # Better price\n\n# When a buy order comes in at 2000.00, it will match with sell2 first\n# due to price improvement, even though sell1 was added first\norderbook.add_order(\"buy1\", Side.BUY, 2000.00, 0.5)\n</code></pre>"},{"location":"user-guide/#customizing-the-order-book","title":"Customizing the Order Book","text":"<p>You can customize various aspects of the order book:</p> <pre><code>from manticore_orderbook import OrderBook\nfrom manticore_orderbook.matchers import PriceTimeMatcher\n\n# Create an order book with custom settings\norderbook = OrderBook(\n    base_asset=\"BTC\",\n    quote_asset=\"USD\",\n    price_precision=2,        # 2 decimal places for price\n    quantity_precision=8,     # 8 decimal places for quantity\n    enable_price_improvement=True,\n    matcher=PriceTimeMatcher()  # Explicit matcher algorithm\n)\n</code></pre>"},{"location":"user-guide/#performance-tips","title":"Performance Tips","text":"<ol> <li> <p>Batch Processing    If adding multiple orders at once, add them all before calling <code>match_orders()</code> to reduce processing overhead.</p> </li> <li> <p>Limit Snapshot Size    When getting book snapshots, specify limits to reduce data size:    <pre><code># Get only top 5 bids and asks\nsnapshot = orderbook.get_snapshot(bid_limit=5, ask_limit=5)\n</code></pre></p> </li> <li> <p>Event Handling    Keep event handlers lightweight. For heavy processing, queue events and process asynchronously.</p> </li> <li> <p>Order ID Generation    Use efficient order ID generation. Shorter strings use less memory.</p> </li> </ol>"},{"location":"user-guide/#visualizing-the-orderbook","title":"Visualizing the OrderBook","text":"<p>Manticore OrderBook comes with a built-in visualization tool that provides a real-time view of the order book, trades, and market metrics.</p>"},{"location":"user-guide/#running-the-visualizer","title":"Running the Visualizer","text":"<p>To start the OrderBook visualizer:</p> <pre><code>python3 -m tests.visual.orderbook_visualizer\n</code></pre> <p>By default, this will: - Start a web server on http://127.0.0.1:5000 - Create a simulated order book for BTC/USD - Auto-generate random orders to demonstrate functionality</p>"},{"location":"user-guide/#using-the-shell-script","title":"Using the Shell Script","text":"<p>For convenience, you can also use the provided shell script:</p> <pre><code># Make the script executable (first time only)\nchmod +x manticore_orderbook/examples/start_visualizer.sh\n\n# Run the visualizer\n./manticore_orderbook/examples/start_visualizer.sh\n</code></pre> <p>The shell script provides a more user-friendly interface with the same options:</p> <pre><code>./manticore_orderbook/examples/start_visualizer.sh --symbol ETH/USD --port 8080\n</code></pre> <p>Or using short options:</p> <pre><code>./manticore_orderbook/examples/start_visualizer.sh -s ETH/USD -p 8080 -d\n</code></pre>"},{"location":"user-guide/#customizing-the-visualizer","title":"Customizing the Visualizer","text":"<p>The visualizer accepts several command-line arguments:</p> <pre><code>python3 -m tests.visual.orderbook_visualizer --symbol ETH/USD --port 8080 --no-generate\n</code></pre> <p>Available options: - <code>--symbol</code>: Set the trading pair symbol (default: BTC/USD) - <code>--port</code>: Set the web server port (default: 5000) - <code>--host</code>: Set the web server host (default: 127.0.0.1) - <code>--no-generate</code>: Disable automatic generation of random orders - <code>--debug</code>: Enable debug mode with additional logging</p>"},{"location":"user-guide/#interacting-with-the-visualizer","title":"Interacting with the Visualizer","text":"<p>The web interface allows you to: - Place limit, market, and stop-limit orders - View the current state of the order book - Track your open orders and cancel them if needed - See recent trades and market metrics - Toggle between light and dark themes </p>"}]}